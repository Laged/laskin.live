<html>

<head>
    <title>laskin.live</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>&#128169;</text></svg>">
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@531&display=swap" rel="stylesheet">
    <style>
        * {
            box-sizing: border-box;
            font-family: "Inter", -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
        }

        body {
            display: grid;
            justify-items: center;
            gap: 2rem;
            min-width: 10em;
        }

        #pooling {
            display: grid;
            grid-template-rows: repeat(4, 1fr);
            grid-template-columns: repeat(3, 1fr);
            gap: 0.5em;
        }

        #pooling label {
            text-align: right;
        }

        #calculator {
            border: 2px solid black;
        }

        #result {
            padding: 0.5em;
            min-height: 4rem;
            line-height: 2rem;
            border-bottom: 1px solid black;
            margin: 0;
        }

        #buttons {
            display: grid;
            grid-template-rows: repeat(4, 1fr);
            grid-template-columns: repeat(3, 1fr);

        }

        #error {
            color: red;
            text-align: center;
        }

        #stdout {
            background-color: black;
            color: white;
            max-height: 50vh;
            overflow-y: scroll;
        }
    </style>
</head>

<body>
    <h1>&#128169;laskin.live</h1>
    <form id="pooling" onsubmit="return false;">
        <label for="status">Status:</label>
        <span id="status">disconnected</span>
        <span></span>

        <label for="webrtc-id">Your ID:</label>
        <input autocomplete="off" disabled name="webrtc-id">
        <input type="submit" value="Host">

        <label for="webrtc-id-foreign">Their ID:</label>
        <input autocomplete="off" placeholder="your friend's id here" name="webrtc-id-foreign">
        <input type="submit" value="Join">
    </form>
    <form id="calculator" method="POST" enctype="multipart/form-data" onsubmit="return false;">
        <input autocomplete="off" id="formula" name="formula" pattern="[0-9a\+\s]*" minlength=3 required>
        <h2 id="result"></h2>
        <div id="buttons">
            <input type="button" value="7">
            <input type="button" value="8">
            <input type="button" value="9">
            <input type="button" value="4">
            <input type="button" value="5">
            <input type="button" value="6">
            <input type="button" value="1">
            <input type="button" value="2">
            <input type="button" value="3">
            <input type="button" value="0">
            <input type="button" value="+">
            <input type="submit" value="=">
        </div>
    </form>
    <p id="error"></p>
    <div id="stdout"></div>
</body>
<script type="module">

    const poolingLogic = async (e) => {
        e.preventDefault();
        const content = new FormData(e.target)
        switch (e.submitter.value) {
        case "Host":
            await initializeConnection(e.target.querySelector("[name='webrtc-id']"))
            await host();
            e.submitter.disabled = true
            e.target.querySelector("[value='Join']").value = "Allow"
            e.target.querySelector("[name='webrtc-id-foreign']").required = true
            break;
        case "Allow":
            await allow(content.get("webrtc-id-foreign"))
            e.submitter.disabled = true
            e.target.querySelector("[name='webrtc-id-foreign']").disabled = true
            break;
        default: // default to Join
            await initializeConnection(e.target.querySelector("[name='webrtc-id']"))
            await join(content.get("webrtc-id-foreign"))
            e.target.querySelector("[value='Host']").disabled = true
        }
        return false
    }

    // **********
    // CONNECTION
    // **********
    const domlog = data => {
        let msg = document.createTextNode(data);
        let container = document.createElement("p");
        container.appendChild(msg);
        document.getElementById('stdout').prepend(container);
    };
    let connection;
    var peers = new Array();
    let worker = false;
    const handleMessage = async e => {
        domlog("REQ peer (" + e.target.id + "@" + e.target.label + "): " + e.data);
        if (worker) {
            const formula = interprete(e.data);
            const res = await gpuEval(formula);
            domlog("RES peer (" + e.target.id + "@" + e.target.label + "): " + res);
            for (let p of peers) {
                p.send(res.join(" "));
            };
            return;
        };
        setResult(e.data);
    };
    const showState = () => {
        console.log("-----State change-------");
        console.log("signalingState", connection.signalingState);
        console.log("connectionState", connection.connectionState);
        console.log("------------------------");
        document.getElementById("status").innerHTML = connection.connectionState;
    };
    const initializeConnection = async (target) => {
        // Connect to STUN servers and enable logging
        connection = new RTCPeerConnection({
            iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
        });
        connection.onconnectionstatechange = showState;
        connection.onsignalingstatechange = showState;
        // Open client data channel
        connection.ondatachannel = event => {
            peers.push(event.channel);
            event.channel.onmessage = handleMessage;
            worker = true;
        };
        // Createa a local offer to be shared with ICE candidate
        connection.onicecandidate = event => {
            if (event.candidate) {
                const offer = connection.localDescription;
                // Store the offer and ice candidate to HTML DOM
                target.value = btoa(JSON.stringify({
                    ICE: JSON.parse(JSON.stringify(event.candidate)), // JS deep copy idiom
                    sdp: { type: offer.type, sdp: offer.sdp },
                }));
            }
        };
    };
    const host = async () => {
        // Open host data channel
        const channel = connection.createDataChannel("laskin.live");
        channel.onmessage = handleMessage;
        channel.onopen = event => peers.push(event.currentTarget);
        const offer = await connection.createOffer(); // calls onicecandidate event
        await connection.setLocalDescription(offer);
    };
    const allow = async (id) => {
        const { ICE, sdp } = JSON.parse(atob(id));
        await connection.setRemoteDescription(sdp);
        await connection.addIceCandidate(ICE);
    };
    const join = async (id) => {
        const { ICE, sdp } = JSON.parse(atob(id));
        await connection.setRemoteDescription(sdp);
        const answer = await connection.createAnswer(); // calls onicecandidate event
        await connection.setLocalDescription(answer);
        await connection.addIceCandidate(ICE);
    };
    // **********
    // CALCULATOR
    // **********

    // Import glslang to compile kernels into bytecode
    import glslangModule from 'https://unpkg.com/@webgpu/glslang@0.0.15/dist/web-devel-onefile/glslang.js';

    // GPU-runnable kernels for each operand
    const kernels = {
        "+":
            `#version 450
        layout(std430, set = 0, binding = 0) buffer LeftBuffer {
            float numbers[];
        } lhs;

        layout(std430, set = 0, binding = 1) buffer RightBuffer {
            float numbers[];
        } rhs;

        void main() {
            uint index = gl_GlobalInvocationID.x;
            lhs.numbers[index] += rhs.numbers[index];
        }`
    };

    // Run a kernel on the GPU with the given arguments
    const run = async (kernel, args) => {
        // Initialize WebGPU
        const glslang = await glslangModule();
        const adapter = await navigator.gpu.requestAdapter();
        const device = await adapter.requestDevice();
        // Initialize GPU buffers through typed arrays from arguments
        var l = [];
        var ls = [];
        args.forEach((v, i) => {
            const a = new Float32Array(v);
            const [buf, loc] = device.createBufferMapped({
                size: a.byteLength,
                usage: GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC,
            });
            new Float32Array(loc).set(a);
            buf.unmap();
            l.push({binding:i, visibility:GPUShaderStage.COMPUTE, type:"storage-buffer"});
            ls.push({binding:i, resource:{ buffer:buf }});
        });
        const layout = device.createBindGroupLayout({entries: l});
        const bindGroup = device.createBindGroup({layout: layout, entries: ls});
        const computePipeline = device.createComputePipeline({
            layout: device.createPipelineLayout({ bindGroupLayouts: [layout] }),
            computeStage: {
                module: device.createShaderModule({
                    code: glslang.compileGLSL(kernel, "compute")
                }),
                entryPoint: "main",
            }
        });
        const lhs = new Float32Array(args[0]);
        // Create a command encoder and run a compute pass to get a result
        const commandPool = device.createCommandEncoder();
        const commandBuffer = commandPool.beginComputePass();
        commandBuffer.setPipeline(computePipeline);
        commandBuffer.setBindGroup(0, bindGroup);
        commandBuffer.dispatch(lhs.length, 1, 1);
        commandBuffer.endPass();
        const deviceBuffer = device.createBuffer({
            size: lhs.byteLength,
            usage: GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ,
        });
        commandPool.copyBufferToBuffer(ls[0].resource.buffer, 0, deviceBuffer, 0, lhs.byteLength);
        device.defaultQueue.submit([commandPool.finish()]);
        // Read result from GPU memoery
        return new Float32Array(await deviceBuffer.mapReadAsync());
    };

    // Evaluate a formula to be runnable on the GPU
    const gpuEval = async (formula) => {
        // Only allow a formula of exactly two integer-only arrays
        if (
            formula.length != 2
            || formula.some(arg => !Array.isArray(arg))
            || formula.some(arg => arg.some(val => typeof val !== 'number'))
        ) {
            console.log("Parse error on gpuEval");
            return;
        }
        // TODO add support for other operands
        const result = await run(kernels["+"], formula);
        return result;
    }

    // Interprete a text to a formula acceptably by the GPU calculator
    const interprete = (text) => {
        // Convert all arguments to numbers
        const convert = (formula) => formula.map(arg => parseInt(arg, 10));
        // Allow returning a single number
        const hasAddition = [...text].some(c => c === "+");
        if (!hasAddition) return convert([text]);
        // Or exactly two arrays split by a plus (+)
        const args = text.split("+");
        if (args.length !== 2) return [];
        const nested = args.map(arg => convert(arg.trim().split(" ")));
        // Expand scalar arguments to match the other argument in length ("1 + 1 2 3 => 1 1 1 + 1 2 3")
        const left = nested[0];
        const right = nested[1];
        const lenLeft = left.length;
        const lenRight = right.length;
        if (lenLeft === 1 && lenRight > 1) {
            return [right.map(c => left[0]), right];
        }
        if (lenRight === 1 && lenLeft > 1) {
            return [left, left.map(c => right[0])];
        }
        // Only allow arrays of equal length, ie "2 2 + 3 3" but not "2 2 + 3 3 3"
        if (nested.some(arr => arr.length !== lenLeft)) return [];
        return nested;
    }

    // Display errors or results in DOM
    const setError = (error) => document.getElementById("error").innerHTML = error;
    const setResult = (result) => {
        document.getElementById("result").innerHTML = result;
        setError("");
    };

    // Handle the calculator logic from the HTML form
    const calculatorLogic = async (e) => {
        e.preventDefault();
        const content = new FormData(e.target).get("formula");
        // Don't allow workers to send data
        if (!worker) {
            for (let p of peers) {
                p.send(content);
            };
        };
        const formula = interprete(content);
        switch (formula.length) {
            // Dyadic sum: calculate the sum of the two numbers
            case 2:
                const res = await gpuEval(formula);
                setResult(res.join(" "));
                break;
            // Monadic sum: a number equals itself
            case 1:
                setResult(formula);
                break;
            // Missing/invalid arguments: show an error
            case 0:
                setError("Invalid/missing arguments");
                break;
        };
        return false;
    };

    // Initialize DOM<>JS<>WEBRTC<>GPU interactions
    window.onload = () => {
        // Buttons append elements to the formula
        const push = (elem) => document.getElementById("formula").value += elem.target.value;
        document.querySelectorAll("#calculator input[type=button]").forEach(elem => elem.onclick = push);
        // Submitting calculates the formula on the GPU and displays the result/error
        document.getElementById("calculator").onsubmit = calculatorLogic;
        document.getElementById("pooling").onsubmit = poolingLogic;
    };
</script>

</html>